VS code uses something called "EMMET" that generates code for us.

The <script> tag is used to embed a client-side script(JS)

In an HTML document, the document.createElement() method creates the HTML element specified by tagName, or an HTMLUnknownElement if tagName isn't recognized.

The getElementById() method of the Document interface returns an Element object representing the element whose id property matches the specified string

.appendChild() appends an ID to the list

Read about CORS

Creating a root & rendering something inside it is the job of react DOM

A react element is nothing but a JS object.

.createElement creates an object which converts into HTML when it renders onto the DOM.

When we use root.render(something here) to pass something into the root all the contents of the root will get replaced with whatever we passed.

React is a library which can work in a small portion of the code we specify & touch nothing else.

NPM doesnt have any full form ( Node package manager is wrong ). NPM is a package manger but doesn't have a full form.

package.json is a configuration for NPM. It keeps track of the approx version intalled on system
package-lock.json keeps track of every version installed along with current exact version. its imp to put both on github unlike "package.json".

if we have package.json & package-lock.json with us we can recreate all of the node modules which is why we push them to git unlike "package.json". 

A -D before an install command means we are installing the developer version of that thing
E.g. npm install -D parcel

dependencies can have their own dependencies called transitive dependencies.

npx executes a package

"npx parcel index.html" basically goes to source.html & builds a development build for our App & hosts it to localHost.

Using CDN links( links to download react modules) isn't a good way to bring React into a project coz its a costly operation & as react keeps updating we will have to keep changing the link to the newer versions.

its better to install react & import react in "index.html" as the earlier react was being imported form the CDN links
e.g. import React from "react".

parcel makes changes to the website in real-time as soon as the code is saved( like live server)

Things that parcel does for us:
Dev build
Creates a Local server
HMR = Hot Module Replacment ( changing website in real-time )
HMR using File Watching Algorithm - written in C++
Caching - Faster builds
Image Optimization -reducing image sizes ( very expensive to load images in web-pages)
Minification , Bundling , Compressing 
consistent hashing , Code splitting , Differential Bundling -supports older browsers along with all current 
Diagnostics , Good error handling, Can host webiste on HTTPs 
tree shaking - removes unsed code
Different dev & prod build 

How to use prod build : npx parcel build index.html
we have to remove the " main : " in pacakge.json to remove the error as main was a way to tell npm the entry point of the app.
Parcel gives the entry point at "index.html" in "npx parcel build index.html".

When we use " npx parcel index.html" , it generates a dev build & hosts it into the folder "dist".

.parcel-cache & dist should be put in git ignore as these files can be easily regenerated

"browserslist" :[] specifies what browsers &  browser verisons our app will MOST DEFINETLY run ( see browser list.dev website)
It might run on older versions, it's not guaranteed.

                        EPISODE 3

We can create scripts to automatically create dev & prod builds

Scripts go in "package.json":
"scripts": {
    "start": " blah .html",  // this is a dev build
    "production" : " ", // name of the scripts can be anything
}

To run a script we just write "npm run start" or "npm start" & it will call the script at "start"
To build the project write "npm run build".

JSX is a JS syntax that makes it easier to create React elemnts.

JSX is not a part of React & isn't compulsory to write React.

JSX is not "HTML inside JS" . It has HTML like syntax.

Browsers are unable to read JSX. Parcel transpiles(converts) JSX into React.createElement() using something called Babel which broswers understand.

Attributes in JSX use camelCase:
e.g. <h1 className="head" tabIndex="1"></h1>

wrapped with () if code is in multi-lines :
e.g. (<h1 A="head">
        blah blah </h1>);

2 types of React components :

Class Based Components - OLD , not used anymore
Functional components - NEW

A Functional component is a normal JS function which returns some JSX code/react element or bunch of react elements.

A functional componet name starts with a capital letter( unlike react elements that use camelCase)

Two ways to write return code when using arrow func which return the same thing :

const HeadingComponent = () => {
    return <h1 className ="heading">namsate react fucntional componet</h1>;
};

const HeadingComponent = () => (
    <h1 className ="heading">namsate react fucntional componet</h1>;
);

To render a component using JSX:
root.render( <HeadingComponent />);

To render a component inside another componet:

    const a = () => <h1> </h1>

    const b = () => (
        <div>
            <a />   <!-- This can also be written as <a></a> --!> 
            <a></a> <!-- no limit to how many times this can be called !-->
            <h1> </h1>
        </div>    
    );

    root.render(<b>);

This is also called "Component Composition".

To return a function without the arrow functions using JSX:

    const HeadingComponent = ()  {
        return (
            <h1 className ="heading">namsate react using JSX</h1>;
        );
    }; 

We can inject any JS code in JSX just by writing that code inside {}.
e.g.

    const number  = 10;

    const HeadingComponent = ()  (
        <div id="container">
            <h2>{console.log("blah blah )}</h2>   // this will print blah blah in the console
            <h3>{number + 100}                    // this will print 110 in the main page
            <h1 className ="heading">namsate react using JSX</h1>;
        </div>
    ); 

    We can put anything inside anything in JSX
    e.g. React element inside a react elemnt , react elemnt inside a functional component,  a functional into functional.

    JSX prevents cross-site scripting attacks for us( checks the data for malicious code ).

We can even call a function inside JSX.

e.g. 
    const a =() =>( <h1>Y</h1 );

    const b = () => ( <div> {a()} </div> );

can also be called as : <a /> 0r <a></a>.

                                EPISODE 4

A mockup or "wireframe" of our webSite or webPage is very important to build beforehand before building the said website/page

CSS can be written using inlineStyles( not preferred)
e.g.

const styleCard = {
}

const RestrauntCard = () => {
    return(
        <div className="res-card" style={styleCard} >
            <h1>Samad</h1>
        </div>    
    );
};

or even :

const RestrauntCard = () => {
    return(
        <div className="res-card" style={ {backgroundColor: "grey"0} }> 
            <h1>Samad</h1>
        </div>    
    );
};

here backgroundColor has 2 curly barces : the first brace is telling us & JSX that the code inside it is "javaScript code" & the second brace tells us that it's  "a javascript object".

Props are used to dynamically pass data into a component,

since a functional component is just a normal JS func , props are just arguments to a function. 

When making a list in react each of the list item should be given a unique key.

If there a list of RestrauntCards in which the restraunts don't have a key & a new card is entered into the list 
react will reRender all of the RestrauntCards again as it has no way to differentiate b/w them costing us massive performance.

Whenever we are doing something in loop or making a list , ALWAYS generate keys.

NEVER USE INDEXES AS KEYS AS THE ORDER ITEM MIGHT CHANGE.

// to get cloudinary ID , open image in new tab & check 

                                    LEC -5 

Never keep Hard coded data( unchangable data ) in the component folder.

The "utils" folder contains the utilities( hard coded data ) that will be used all over the app.

One file can only have one default export.

To export multiple things simply write export before them. This is called "named export".

To import a named export :
e.g. import {FILE_NAME} from "../path/deeperpath"

Its a good idea to keep files < 100 lines. Create separate components as needed.


# React Hooks
--Normal JS utility function
--Made by FB devs 
 -useState() --Superpowerful State Variables in React
 -useEffect() 

 
useState is imported as a named import.
e.g. import { useState } from "react";


Just as a normal JS variable has a scope inside a function , a "Local State variable" has a scope inside the component.

e.g. of State Variable :
const [variableName] = useState([]);
whatever is in the [] becomes the default value of the variable. 


Normal JS variab
le:
let listOfRestraunts =[];

A "local state variable" in react is very super powerful which is created in a diff way from a normal var by using hooks.

e.g. const [listOfRestraunts , setListOfRestraunts] = useState();

here "setListOfRestraunts" is used to update "listOfRestraunts".
it is a recommended nomenclature to use "set" before the name of the local state variable. 

We can't modify this variable directly but use .filter() :

const filteredList = listOfRestraunts.filter(
        (res) => res.data.avgRating > 4
);

setListOfRestraunts(filteredList);

Whenever a state variable updates , react rerenders the component.

A virtual DOM is a representation of an Actual DOM.

A virtual DOM is a JS object at the end of the day.

React modfies the UI elements after some changes have been made ( e.g. using filter ) by using something called "RECONCILATION ALGORITHM" (react fiber).

A virtual DOM got created when some data was put in listOfRestraunts =[] . When this list was filtered ( i.e. change was made to a state variable) another virtual DOM was created .

When React sees a diff b/w these 2 DOM's using the Reconciliation algorithm then it updates the actual DOM.


"React is fast as it is doing efficient DOM manipulation using the Reconciliation algorithm". Basically react can efficiently find out the diff. b/w virtual DOM's & update the UI.

The set part of the declaration of the useState is a trigger for the diff algo to run.
Whenever the set"listName" is called the algo will run & automatically rerender the component.

We can "destructure on the fly" the way to use useState ( hooks maybe ?? )

e.g.
const [listOfRestraunts , setListOfRestraunts] = useState();

is the same as:
const arr = useState(resList);
const [listOfRestraunts, setListOfRestraunts] = arr;

which is the same as:
const arr = useState(resList);
const listOfRestraunts = arr[0];
const setListOfRestraunts = arr[1];

episode 4: 1:45min ; explanation of why onChange is used ??


                                            LEC - 6

An older way to make project architecture was "monolith" where all project elements such as API , UI , DB were all bundled together.

A modern way to make projects is using "Microservices" architecture where we have diff service for diff jobs called microservices.
All these services combined together would make a big app.  

All these services talk to each other depending on use cases which is termed as "separation of consoles" & " a single responsibilty principle" where each 
 & every service has its own job & noBody is interferring with it.

The microservices can be written in diff languages unlike monolith.

These services each run on diff ports.( 1000 , 1234 ->UI) & all these ports can be mapped to the same domain name.

In react we render pages like this:

Page Loads --> Render --> API call --> Render

This way of rendering has better UX & as react is very fast at rendering, rendering the page twice isnt a issue.

Syntax of useEffect includes a callback function along with a dependancy array.

If we have to do something after a component has rendered , we use useEffect.

const body = () => {

useEffect(()=>{
    console.log("useEffect Called");
} , []);

return (rest of the body ) }

The callback function is called after the "body" component renders.

The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses.
The fetch() function returns a Promise which is fulfilled with a Response object representing the server's response.

If we want to make our component dynamic( something changes in the comp.)  JS variables cant work in this cases.
We use useState for such cases as react rerenders the component.

const Header =() => {

const[ btnNameReact, setBtnNameReact] = useState("Login");

return (
    <div className="nav-items">
        <ul>
            <li>Home</li>
            <li>Cart</li>
            <button className="login" onClick={() => {setBtnReact("logout);} }
        </ul>
    </div>
);
}

In the above eg, when onclick is called, react will reRender the entire Header component & not just the "Login" button.
This is the reason why a seemingly const variable appears to be changing its value. As react is re-rendering a new variable
which might give the impression that a const variable is changing.
This is one of the great fuctionality of React.

Whenever we change a local State variable , react triggers a Reconciliation cycle( rerenders the component).

onChange is used to input text in a search bar.
value={searchText} onChange={ (e) => { setSearchText(e.target.value); } }

Here 'e' means event.

Whenever a letter is entered in the search bar react re-renders the entire page. 

                               
                                ::--EPISODE 7--::

If there is no dependency array then useEffect is called on every render of a component.

If the dependency array is empty = [] => useEffect is only called on initial render( just once ).

If there is something in the dependancy array then its only called when the dependancy changes.

e.g. useEffect(() => {
    console.log("useEffect called");
}, [btnNameReact]);

here useEffect will be called everytime "btnNameReact" changes.

useState can only be called inside the body component.

It is a good practice to create all the state variables at the top of the component.

Never create state variables inside an if-else statement ,  for loops or functions.


Configuration is information that tells the browser router what will happen in a specific path/route.

import { createBrowserRouter , RouterProvider}

createBrowserRouter creates a routing configuration for us. It takes a "list" of paths.

RouterProvider provides the routing configuration to our App. It is exported from the react router dom library.

A function starting with "use" is a hook.

"useRouteError" gives us more information about the error.

We should not use anchor tags ( a href = ".." ) in React as it reloads the entire page.

the "link" component lets us link to different pages ( such as "Contact us" , "About Us" ) without realoading the page.
It just refreshes the components.

This is why react app's are known as "single page app's ".

Link is a special component provided by react router DOM. It is a wrapper over an anchor tag ( 2:11:00 ).
Any "link" inside the component link will be tracked by react router DOM 

There are 2 types of routing in web app's:
-Client Side Routing
-Server Side Routing ( re-renders the whole page as a network call is made)

A class based component is written as:
class UserClass extends React.component {
    constructor(props) {
        super(props);
    }

    render() {
        return
    }
}

Here "extends React.component" lets react know that UserClass is a class based component.

Class Based Component has a render component that returns some piece of JSX.

"React.component" is a Class given to us by react & "userClass" is inhereting some properties from it.

In a class based component we use a constructor to pass data as props.

this.state() is used to create a variable inside a class based comp.

We should never update state variables directly.
e.g.

"this.state.count = this.state.count + 1 ;" is wrong.

"this.setState()" is used to update state variables in class based components.

e.g. this.setState({
    count: this.state.count + 1,
});

When react sees a class based component it starts loading it i.e. It goes the component & creates a new instance of this class
 which means the constructor & then render of that class is called.

 Check lec 8 ; 1:01:01 for lifecycle of Parent constructer , render , component & Child constructor , render & component.

 When using componentDidMount() in a parent & Child constructor,The render/mount sequence will be as follows:

 Parent constructer --> moves to parent child which calls the Child constructor --> render component --> componentDidMount in the child constructor --> back to Parent & then componentDidMount in the parent.

 API calls are made inside of "componentDidMount" as its better to render first while we wait for data.

1:19:20

To check React methods lifecycle diagam: 
https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

Manipulating/updating DOM is an expensive task..react tries to batch things up. 

In class based component , we make an API call in an async componentDidMount() & use await fetch() inside it to fetch an API.

Check the lifecycle of components at 1:47:00 lec 8 .

For more depth into the lifecycle check 2:01:52.

When a file name starts with "use" React will understand that the file is a hook.

It's the recommended practice to start the names of component files with a capital letter & to write useFileName for a hook.

Chunking / Code splitting / Dynamic bundling is breaking down the app into smaller logical chunks.


